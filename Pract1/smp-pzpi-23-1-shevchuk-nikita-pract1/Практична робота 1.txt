Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії



ЗВІТ 
З практичної роботи №1
з дисципліни «Скриптові мови програмування»




Виконав:	Перевірив:
ст. гр. ПЗПІ-23-1	ст. викладач катедри ПІ
Шевчук Нікіта	Сокорчук Ігор Петрович













Харків 2025
ПРАКТИЧНА РОБОТА №1
      1 ІСТОРІЯ ЗМІН

Таблиця 1.1 – Історія змін
№ДатаВерсія звітуОпис змін та виправлень109.06.20250.1Створено звіт     
      2 ЗАВДАННЯ

      Написати Bash скрипт, який друкуватиме на екрані ялинку із двох ярусів гілок, стовбура та шару снігу.
      
      3 ОПИС ВИКОНАНОЇ РОБОТИ

      Цей bash-скрипт реалізує функціональність для малювання ASCII-арт ялинки з заданими параметрами. Скрипт приймає два аргументи командного рядка: висоту ялинки та ширину снігового покриву. Функція error_exit відповідає за виведення повідомлення про помилку та завершення роботи програми з кодом помилки [див. додаток Б, рядки 3-6]. 
      Основна логіка малювання реалізована у функції draw_line, яка приймає символ для малювання, ширину лінії та загальну ширину області, після чого центрує лінію та виводить її на екран [див. додаток Б, рядки 8-21].
      Скрипт включає детальну валідацію вхідних параметрів, перевіряючи кількість аргументів, їх числовий формат та додатність значень [див. додаток Б, рядки 23-35].
      Обчислення розмірів різних частин ялинки виконується через визначення максимальної ширини гілок, висоти стовбура та снігового покриву [див. додаток Б, рядки 37-44]. 
      Алгоритм розраховує висоту двох ярусів гілок ялинки, використовуючи цикли для визначення кількості рядків у кожному ярусі [див. додаток Б, рядки 46-58].
      Функція draw_tier відповідає за малювання окремого ярусу ялинки, приймаючи початкову та максимальну ширину, після чого поступово збільшує ширину кожного рядка та чергує символи зірочки та решітки залежно від номера лінії [див. додаток Б, рядки 66-81].
       Основна частина програми послідовно малює два яруси гілок, стовбур ялинки з фіксованою шириною та завершує сніговим покривом на всю задану ширину [див. додаток Б, рядки 83-94].
     
      4 ВИСНОВОК
      У результаті виконання практичної роботи було розроблено Bash-скрипт, який успішно реалізує малювання ASCII-ялинки із двох ярусів гілок, стовбура та снігового шару з урахуванням заданих параметрів висоти та ширини. Скрипт демонструє коректну обробку вхідних даних, обчислення необхідних геометричних параметрів, а також використання функцій для структурованого та гнучкого відображення елементів ялинки. Завдяки розмежуванню логіки малювання ярусів і окремих ліній, програма є зручною для модифікації й масштабування, а її робота підтверджує правильність реалізації всіх вимог завдання.










ДОДАТОК A

Відеозапис презентації результатів лабораторної роботи: https://youtu.be/f8LPFCOsWZI 

Хронологічний опис відеозапису:
00:22 – розповідаю про функцію draw_line, що малює один рядок ялинки
00:55 – перевірки на те, чи валідні аргументи перед запуском роботи 
02:14 – обчислення висоти двох ярусів ялинки
03:04 – про функцію draw_tier, що відповідає за малювання окремого яруса ялинки
04:13 – демонстрація роботи програми













ДОДАТОК Б
Б.1 – Головна програма
GitHub репозиторій: https://github.com/NureShevchukNikita/smp-pzpi-23-1-shevchuk-nikita
 1. #!/bin/bash
 2. 
 3. error_exit() {
 4.     echo "Помилка: неправильне значення аргумента" >&2
 5.     exit 1
 6. }
 7. 
 8. draw_line() {
 9.     local symbol=$1
10.     local width=$2
11.     local total_width=$3
12.     
13.     local spaces=$(( (total_width - width) / 2 ))
14.     
15.     for ((i = 0; i < spaces; i++)); do
16.         printf " "
17.     done
18.     
19.     for ((i = 0; i < width; i++)); do
20.         printf "%s" "$symbol"
21.     done
22.     
23.     printf "\n"
24. }
25. 
26. if [ $# -ne 2 ]; then
27.     error_exit
28. fi
29. 
30. height=$1
31. snow_width=$2
32. 
33. if ! [[ "$height" =~ ^[0-9]+$ ]] || ! [[ "$snow_width" =~ ^[0-9]+$ ]]; then
34.     error_exit
35. fi
36. 
37. if [ "$height" -le 0 ] || [ "$snow_width" -le 0 ]; then
38.     error_exit
39. fi
40. 
41. height=$((height))
42. snow_width=$((snow_width))
43. 
44. max_branch_width=$((snow_width - 2))
45. 
46. if [ "$max_branch_width" -lt 1 ]; then
47.     error_exit
48. fi
49. 
50. trunk_height=2
51. snow_height=1
52. 
53. available_height=$((height - trunk_height - snow_height))
54. 
55. first_tier_height=0
56. width=1
57. while [ $width -le $max_branch_width ]; do
58.     first_tier_height=$((first_tier_height + 1))
59.     width=$((width + 2))
60. done
61. 
62. second_tier_height=0
63. width=3
64. while [ $width -le $max_branch_width ]; do
65.     second_tier_height=$((second_tier_height + 1))
66.     width=$((width + 2))
67. done
68. 
69. total_needed_height=$((first_tier_height + second_tier_height))
70. 
71. if [ $available_height -lt 2 ]; then
72.     error_exit
73. fi
74. 
75. unused_height=$((available_height - total_needed_height))
76. if [ $unused_height -gt 1 ]; then
77.     error_exit
78. fi
79. 
80. draw_tier() {
81.     local start_width=$1
82.     local max_width=$2
83.     
84.     local current_width=$start_width
85.     
86.     while [ $current_width -le $max_width ]; do
87.         local symbol
88.         if [ $((global_line_counter % 2)) -eq 0 ]; then
89.             symbol="*"
90.         else
91.             symbol="#"
92.         fi
93.         
94.         draw_line "$symbol" "$current_width" "$snow_width"
95.         current_width=$((current_width + 2))
96.         global_line_counter=$((global_line_counter + 1))
97.     done
98. }
99. 
100. global_line_counter=0
101. 
102. draw_tier 1 $max_branch_width
103. 
104. draw_tier 3 $max_branch_width
105. 
106. trunk_width=3
107. count=0
108. until [ $count -ge $trunk_height ]; do
109.     draw_line "#" "$trunk_width" "$snow_width"
110.     count=$((count + 1))
111. done
112. 
113. draw_line "*" "$snow_width" "$snow_width"
2


